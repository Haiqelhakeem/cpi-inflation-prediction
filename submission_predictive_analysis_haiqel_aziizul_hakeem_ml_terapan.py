# -*- coding: utf-8 -*-
"""Submission Predictive Analysis - Haiqel Aziizul Hakeem - ML Terapan.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ulXVl5ecKcy8vgW9PyciWQAFglHR_eGl

# Proyek Predictive Analysis: Sticky Price Consumer Price Index less Food and Energy
- **Nama:** Haiqel Aziizul Hakeem
- **Email:** a547ybm193@devacademy.id
- **ID Dicoding:** A547YBM193

## Business Understanding

Pada project kali ini saya akan memprediksi inflasi harga produk yang tidak sering berubah dalam jangka panjang atau biasa disebut Sticky Price Consumer Price Index. Dataset yang digunakan diambil dari website [Federal Reserve Bank of St. Louis](https://fred.stlouisfed.org) dengan judul Sticky Price Consumer Price Index less Food and Energy.

Problem Statements:
* Bagaimana cara kita membangun model secara akurat serta memprediksikan inflasi dari Sticky Price CPI menggunakan arsitektur Deep Learning seperti LSTM,dan Gru?

Goals:
1. Memahami trend dari Sticky Price CPI menggunakan EDA
2. Preprocess dan mengubah data time series ke dalam deep learning model
3. Mengembangkan dan membandingkan model LSTM, dan Gru
4. Evaluasi kinerja model
5. Menentukan model yang terbaik berdasarkan hasil evaluasi

## Import Semua Packages/Library yang Digunakan

Pada bagian ini dilakukan import berbagai library yang dibutuhkan untuk proyek:
- `pandas`, `numpy`: manipulasi data
- `matplotlib.pyplot`: visualisasi data
- `gdown`: mengunduh dataset dari Google Drive
- `sklearn`: preprocessing dan evaluasi model
- `tensorflow.keras`: membangun model deep learning (LSTM, GRU)
- `keras.callbacks`: digunakan untuk early stopping, dan mengurangi learning rate.
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import gdown

from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error

import tensorflow as tf
from tensorflow.keras import Input
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, GRU

from keras.callbacks import EarlyStopping, ReduceLROnPlateau

"""## Data Understanding

### Data Loading

Dataset diunduh dari Google Drive menggunakan `gdown`. File yang diunduh disimpan sebagai `cpi.csv`.
"""

file_id = '1E_YcQAFTHhoabpdb9RpgdPUSBhL3aA-z'
output_path = 'cpi.csv'
gdown.download(f'https://drive.google.com/uc?id={file_id}', output_path, quiet=False)

"""Dataset yang telah diunduh dibaca menggunakan `pandas.read_csv` dan disimpan ke dalam variabel `df` untuk proses selanjutnya."""

df = pd.read_csv('cpi.csv')

"""### EDA and Visualization

Menampilkan 5 baris pertama dari DataFrame `df` untuk melihat struktur awal data.
"""

df['observation_date'] = pd.to_datetime(df['observation_date'])
df.rename(columns={'CPALTT01USM657N': 'cpi'}, inplace=True)
df.head()

"""Memberikan gambaran dataset yang digunakan, seperti: jumlah baris, kolom, null, duplikat, tipe data, statistik, dan nilai unik"""

print(f"Jumlah baris: {df.shape[0]}\n")
print(f"Jumlah kolom: {df.shape[1]}\n")
print(f"Jumlah data yang hilang: {df.isna().sum().sum()}\n")
print(f"Jumlah data duplikat: {df.duplicated().sum()}\n")
print(f"Tipe data:\n{df.dtypes}\n")
print(f"Statistik data:\n{df.describe()}\n")
print(f"Jumlah nilai unik:\n{df.nunique()}\n")

"""Tahun 1970-an ditandai volatilitas inflasi ekstrim dengan puncak di atas 1,5. Tahun 1980-2000an menampilkan stabilitas dramatis dengan inflasi terkendali antara -0,5 hingga +1,0. Krisis 2008 menyebabkan deflasi tajam hingga -2,0, diikuti periode stabil hingga lonjakan inflasi sekitar 2020-2022 pasca-pandemi COVID-19. Secara keseluruhan, data menggambarkan transformasi dari era inflasi tidak terkendali menuju sistem moneter modern yang lebih stabil."""

plt.plot(df['observation_date'], df['cpi'])
plt.title("Sticky CPI Over Time")
plt.xlabel("Date")
plt.ylabel("CPI")
plt.grid(True)
plt.show()

"""## Data Preparation

Proses selanjutnya adalah normalisasi skala data menggunakan `MinMaxScaler` kemudian membuat function sequence yang diperlukan untuk model LSTM dan GRU. Hal ini memungkinkan data dijadikan ke dalam bentuk sequence agar bisa dijadikan input oleh model LSTM dan GRU. Kemudian menentukan `SEQ_LEN`, atau seberapa banyak bulan yang akan kita gunakan untuk memprediksi data selanjutnya.
"""

# Normalization
scaler = MinMaxScaler()
scaled = scaler.fit_transform(df[['cpi']])

# Sequence for LSTM and GRU
def create_sequences(data, seq_len):
    X, y = [], []
    for i in range(len(data) - seq_len):
        X.append(data[i:i+seq_len])
        y.append(data[i+seq_len])
    return np.array(X), np.array(y)

SEQ_LEN = 12
X, y = create_sequences(scaled, SEQ_LEN)

"""Kemudian adalah split data. Data dibagi menjadi 80:20 untuk train dan test."""

split = int(0.8 * len(X))
X_train, y_train = X[:split], y[:split]
X_test, y_test = X[split:], y[split:]

"""## Modelling

Sekarang adalah proses modeling. Hal pertama yang dilakukan adalah menentukan callbacks yang akan digunakan. Dalam hal ini, kita menggunakan `EarlyStopping` dan `ReduceLROnPlateau`. `Early Stopping` untuk menghentikan proses training jika parameter yang kita masukkan tidak mengalami perkembangan yang signifikan dalam beberapa epoch, dalam hal ini parameternya adalah `val_loss` selama 5 epoch. Lalu `ReduceLROnPlateau` untuk mengurangi learning rate jika perkembangan lambat selama epoch yang ditentukan, dalam hal ini selama 3 epoch dan dikurangi sebanyak 0.5.
"""

callbacks = [
        EarlyStopping(patience=5, restore_best_weights=True, monitor='val_loss'),
        ReduceLROnPlateau(factor=0.5, patience=3, verbose=1)
    ]

"""Pada cell ini dilakukan proses pelatihan dan evaluasi model Long Short-Term Memory (LSTM) untuk melakukan prediksi berdasarkan data time series yang telah diproses sebelumnya. <br>
Model terdiri dari:
- Input Layer: Menerima data berukuran (SEQ_LEN, 1).
- LSTM Layer: Memiliki 64 unit dengan aktivasi tanh.
- Dense Layer: Satu neuron untuk memprediksi nilai akhir. <br>

Kemudian model dicompile dengan:
- Optimizer: adam
- Loss function: Mean Squared Error (MSE)

`summary()` menampilkan arsitektur model dan jumlah parameter.

### LSTM Model
"""

# LSTM
lstm_model = Sequential([
    Input(shape=(SEQ_LEN, 1)),
    LSTM(64, activation='tanh', return_sequences=False),
    Dense(1)
])

lstm_model.compile(optimizer='adam', loss='mse')
lstm_model.summary()

"""Cell berikut merupakan pelatihan model dengan `fit()`
- Model dilatih selama 50 epoch dengan batch size 32.
- Validasi dilakukan menggunakan data `X_test` dan `y_test`.
- Callbacks digunakan untuk mengontrol training seperti dengan `Early Stopping` dan `ReduceLROnPlateau`
"""

lstm_history = lstm_model.fit(
        X_train, y_train,
        validation_data=(X_test, y_test),
        epochs=50,
        batch_size=32,
        callbacks=callbacks,
        verbose=2
    )

"""Prediksi dilakukan terhadap data `X_test`. Hasil prediksi dan label asli dikembalikan ke skala aslinya menggunakan `inverse_transform`. Hasilnya sendiri menunjukkan nilai MAE=0.2819 dan RMSE=0.3440.

"""

# LSTM
# Predict and evaluate
lstm_preds = lstm_model.predict(X_test)
lstm_preds_inv = scaler.inverse_transform(lstm_preds)
y_test_inv = scaler.inverse_transform(y_test)

# Calculate error metrics
mae = mean_absolute_error(y_test_inv, lstm_preds_inv)
rmse = np.sqrt(mean_squared_error(y_test_inv, lstm_preds_inv))
print(f"LSTM: MAE={mae:.4f}, RMSE={rmse:.4f}")

"""### GRU Model

Selanjutnya adalah model kedua, yakni GRU (Gated Recurrent Unit). Pada cell ini dilakukan proses pelatihan dan evaluasi model untuk melakukan prediksi berdasarkan data time series yang telah diproses sebelumnya. <br>
Model terdiri dari:
- Input Layer: Menerima data berukuran (SEQ_LEN, 1).
- GRU Layer: Memiliki 64 unit dengan aktivasi tanh.
- Dense Layer: Satu neuron untuk memprediksi nilai akhir.

Kemudian model dicompile dengan:
- Optimizer: adam
- Loss function: Mean Squared Error (MSE)

`summary()` menampilkan arsitektur model dan jumlah parameter.
"""

# GRU
gru_model = Sequential([
    Input(shape=(SEQ_LEN, 1)),
    GRU(64, activation='tanh', return_sequences=False),
    Dense(1)
])

gru_model.compile(optimizer='adam', loss='mse')
gru_model.summary()

"""Cell berikut merupakan pelatihan model dengan `fit()`
- Model dilatih selama 50 epoch dengan batch size 32.
- Validasi dilakukan menggunakan data `X_test` dan `y_test`.
- Callbacks digunakan untuk mengontrol training seperti dengan `Early Stopping` dan `ReduceLROnPlateau`
"""

gru_history = gru_model.fit(
        X_train, y_train,
        validation_data=(X_test, y_test),
        epochs=50,
        batch_size=32,
        callbacks=callbacks,
        verbose=2
    )

"""Prediksi dilakukan terhadap data `X_test`. Hasil prediksi dan label asli dikembalikan ke skala aslinya menggunakan `inverse_transform`. Hasilnya sendiri menunjukkan nilai MAE=0.2592 dan RMSE=0.3182."""

# GRU
# Predict and evaluate
gru_preds = gru_model.predict(X_test)
gru_preds_inv = scaler.inverse_transform(gru_preds)
y_test_inv = scaler.inverse_transform(y_test)

# Calculate error metrics
mae = mean_absolute_error(y_test_inv, gru_preds_inv)
rmse = np.sqrt(mean_squared_error(y_test_inv, gru_preds_inv))
print(f"GRU: MAE={mae:.4f}, RMSE={rmse:.4f}")

"""## Evaluasi dan Visualisasi

Berikut adalah visualisasi dari akurasi model LSTM yang telah dilatih dibandingkan dengan data aslinya. Dimana model masih menunjukkan underfitting. Model masih memiliki loss yang cukup besar dibandingkan dengan data aktual, sehingga model masih perlu ditingkatkan.
"""

# LSTM
plt.figure(figsize=(12, 6))
plt.plot(y_test_inv, label='Actual CPI', color='blue')
plt.plot(lstm_preds_inv, label='Predicted CPI (LSTM)', color='orange')
plt.title("LSTM Model: Predicted vs Actual CPI")
plt.xlabel("Time Steps")
plt.ylabel("CPI Value")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

"""Berikut adalah visualisasi dari akurasi model GRU yang telah dilatih. Hasilnya menunjukkan tingkat akurasi yang baik dibandingkan LSTM sebelumnya. Dimana loss yang ditunjukkan tidak sebesar LSTM, namun masih dapat ditingkatkan. Sehingga model ini lebih baik dibandingkan model LSTM sebelumnya."""

# GRU
plt.figure(figsize=(12, 6))
plt.plot(y_test_inv, label='Actual CPI', color='blue')
plt.plot(gru_preds_inv, label='Predicted CPI (GRU)', color='orange')
plt.title("GRU Model: Predicted vs Actual CPI")
plt.xlabel("Time Steps")
plt.ylabel("CPI Value")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

"""## Inference

Berikut adalah tahap inference atau test prediksi. Dimana kita akan menggunakan model GRU untuk prediksi nilai Sticky Price CPI selanjutnya.
"""

n_steps = 12
preds = []

input_seq = scaled[-SEQ_LEN:].reshape(1, SEQ_LEN, 1)

for _ in range(n_steps):
    next_pred = gru_model.predict(input_seq)[0, 0]
    preds.append(next_pred)

    # update input_seq: drop first, append new prediction
    input_seq = np.append(input_seq[:, 1:, :], [[[next_pred]]], axis=1)

# Inverse transform all predictions
future_preds = scaler.inverse_transform(np.array(preds).reshape(-1, 1))

"""- Garis biru menunjukkan data historis CPI dari waktu ke waktu (yang telah dinormalisasi atau distandarisasi).
- Garis merah menunjukkan hasil prediksi CPI di masa depan dari model GRU.
- Sumbu X: Time Step
- Sumbu Y: Nilai Sticky Price CPI
- Prediksi dimulai mendekati akhir dari data historis, menunjukkan jendela prediksi jangka pendek.

Model GRU mampu menangkap tren umum dan menghasilkan prediksi yang lebih halus tanpa banyak noise. Nilai CPI yang diprediksi tampak stabil dengan sedikit tren penurunan.

Berdasarkan grafik tersebut, nilai prediksi awalnya berada di sekitar 0.45, lalu secara perlahan menurun dan stabil di sekitar 0.35 sampai 0.4 pada akhir segmen. Pola ini menunjukkan tren penurunan yang ringan dan pergerakan yang sangat halus. Dimana hal ini sesuai dengan produk dengan kategori sticky price
"""

plt.figure(figsize=(10, 5))
plt.plot(range(len(scaled)), scaler.inverse_transform(scaled), label='Historical CPI')
plt.plot(range(len(scaled), len(scaled) + n_steps), future_preds, label='Future Predictions (GRU)', color='red')
plt.xlabel('Time Step')
plt.ylabel('CPI')
plt.title('Future CPI Prediction using GRU')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()